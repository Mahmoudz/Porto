"use strict";(self.webpackChunkporto=self.webpackChunkporto||[]).push([[884],{3610:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=i(4848),n=i(8453);const o={sidebar_position:7},s="Quality Attributes",r={id:"Quality Attributes",title:"Quality Attributes",description:"Quality attributes are integral to Porto's design and implementation. They ensure the software meets the needs and expectations of its developers.",source:"@site/docs/Quality Attributes.md",sourceDirName:".",slug:"/Quality Attributes",permalink:"/Porto/docs/Quality Attributes",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Quality Attributes.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Monolithic to Microservices",permalink:"/Porto/docs/Features/Monolithic to MicroServices"},next:{title:"Implementations",permalink:"/Porto/docs/Implementations"}},l={},d=[{value:"Modularity &amp; Reusability",id:"modularity--reusability",level:2},{value:"Maintainability &amp; Scalability",id:"maintainability--scalability",level:2},{value:"Testability &amp; Debuggability",id:"testability--debuggability",level:2},{value:"Adaptability &amp; Evolvability",id:"adaptability--evolvability",level:2},{value:"Usability &amp; Learnability",id:"usability--learnability",level:2},{value:"Extensibility &amp; Flexibility",id:"extensibility--flexibility",level:2},{value:"Agility &amp; Upgradability",id:"agility--upgradability",level:2}];function c(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",hr:"hr",p:"p",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"quality-attributes",children:"Quality Attributes"}),"\n",(0,a.jsx)(t.p,{children:"Quality attributes are integral to Porto's design and implementation. They ensure the software meets the needs and expectations of its developers."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"modularity--reusability",children:"Modularity & Reusability"}),"\n",(0,a.jsxs)(t.p,{children:["In Porto, your application business logic lives in Containers. Porto Containers are similar in nature to the Modules ",(0,a.jsx)(t.em,{children:"(from the Modular architecture)"})," and Domains ",(0,a.jsx)(t.em,{children:"(from the DDD architecture)"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Containers can depend on other Containers, similar to how a layer can depend on other layers in a layered architecture."}),"\n",(0,a.jsx)(t.p,{children:"Porto's rules and guidelines minimize and define the dependency directions between Containers, to avoid circular references between them."}),"\n",(0,a.jsx)(t.p,{children:"Additionally, it allows the grouping of related Containers, making it possible to reuse them in different projects. Each section contains a reusable portion of your application's business logic."}),"\n",(0,a.jsx)(t.p,{children:"When it comes to dependency management, the developer is free to move each Container to its own repository or keep all Containers together under a single repository."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"maintainability--scalability",children:"Maintainability & Scalability"}),"\n",(0,a.jsx)(t.p,{children:"Porto aims to reduce maintenance costs by saving developers time. It's structured in a way to ensure code decoupling and forces consistency, which all contribute to its maintainability."}),"\n",(0,a.jsx)(t.p,{children:"Having a single function per class to describe a functionality makes adding and removing features an easy process."}),"\n",(0,a.jsx)(t.p,{children:"Porto has a very organized codebase and zero code coupling. In addition to a clear development workflow with predefined data flow and dependencies directions, all of these contribute to its scalability."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"testability--debuggability",children:"Testability & Debuggability"}),"\n",(0,a.jsx)(t.p,{children:"Extremely adhering to the single responsibility principle by having a single function per class results in having slim classes, which leads to easier testability."}),"\n",(0,a.jsx)(t.p,{children:"In Porto, each component expects the same type of input and output,\nwhich makes testing, mocking, and stabbing straightforward."}),"\n",(0,a.jsxs)(t.p,{children:["The Porto structure itself makes writing automated tests a smooth process. Each container has a ",(0,a.jsx)(t.code,{children:"tests"})," folder at its root to contain unit tests for its tasks. Additionally, each UI folder has a ",(0,a.jsx)(t.code,{children:"tests"})," folder to contain functional tests (for testing each UI separately)."]}),"\n",(0,a.jsx)(t.p,{children:"The key to making testing and debugging easy is not only in the organization of the tests and the predefined responsibility of the components, but also in the decoupling of your code."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"adaptability--evolvability",children:"Adaptability & Evolvability"}),"\n",(0,a.jsx)(t.p,{children:"Porto allows for easy accommodation of future changes with minimal effort."}),"\n",(0,a.jsx)(t.p,{children:"For example, let's say you have a web app that serves HTML and you decide that you also need a mobile app with an API. Porto's pluggable UI's (WEB, API & CLI) enables you to write the business logic of your application first and then implement a UI to interact with your code. This gives you the flexibility to add interfaces as needed and adapt to future changes with ease."}),"\n",(0,a.jsx)(t.p,{children:"The reason this is possible is that Actions are the central organizing principle, not the controller,\nand they can be shared across multiple UI's.\nAdditionally,\nthe UI's are separated from the application business logic and separated from each other within each Container."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"usability--learnability",children:"Usability & Learnability"}),"\n",(0,a.jsx)(t.p,{children:"Porto prioritizes ease of use and understandability. Its implementation of domain expert language when naming classes and adherence to the single function per class rule allow for quick location of any feature or functionality. This means that you can easily find any Use Case (Action) in your code simply by browsing the files."}),"\n",(0,a.jsx)(t.p,{children:"Porto guarantees that you can find any feature implementation in less than 3 seconds. For example, if you are looking for where user addresses are being validated, simply go to the Address Container, open the list of Actions, and search for the ValidateUserAddressAction."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"extensibility--flexibility",children:"Extensibility & Flexibility"}),"\n",(0,a.jsx)(t.p,{children:'Porto takes future growth into consideration and ensures your code remains maintainable no matter how large the project becomes. Its modular structure, separation of concerns, and organized coupling between internal classes ("Components") allows for modifications to be made without undesirable side effects.'}),"\n",(0,a.jsx)(t.p,{children:"Furthermore, Porto's extensibility and flexibility allow for easy integration with other tools and technologies. Its modular structure enables the addition of new functionality without affecting existing code, making it easy to scale the project as needed. This means that Porto is not only a great choice for current projects, but also for those that may require additional features or integrations in the future. The flexibility provided by Porto also allows for easy customization of the codebase to fit specific project requirements. This makes it a versatile choice for a wide range of development needs."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"agility--upgradability",children:"Agility & Upgradability"}),"\n",(0,a.jsx)(t.p,{children:"Porto enables quick and easy movement in the development process."}),"\n",(0,a.jsx)(t.p,{children:"Upgrading the framework is straightforward due to the complete separation between the application and framework code through the Ship layer."}),"\n",(0,a.jsx)(t.p,{children:"Additionally, Porto's pluggable UI's make it easy to add or remove interfaces, and its modular structure enables adding new features or modifying existing ones without causing negative impacts on other parts of the codebase. This agility and upgradability make Porto a great choice for projects that require flexibility and adaptability to future changes."}),"\n",(0,a.jsx)(t.hr,{})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>r});var a=i(6540);const n={},o=a.createContext(n);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);